package de.bund.bfr.knime.pmm.combaseio.lib;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Enumeration;

import de.bund.bfr.knime.pmm.common.PmmTimeSeries;

public class CombaseReader implements Enumeration<PmmTimeSeries> {
	
	private BufferedReader reader;
	private PmmTimeSeries next;
	
	public CombaseReader( final String filename )
	throws FileNotFoundException, IOException, Exception {
		
		reader = new BufferedReader( new InputStreamReader(
			new FileInputStream( filename ), "UTF-16LE" ) );
		step();
	}
	
	public void close() throws IOException {
		reader.close();
	}
	
	public PmmTimeSeries nextElement() {

		PmmTimeSeries ret;
		
		ret = next;
		
		try {
			step();
		}
		catch( Exception e ) {
			e.printStackTrace( System.err );
		}
		
		return ret;
	}
	
	public boolean hasMoreElements() {
		return next != null;
	}
	
	private void step() throws IOException, Exception {
		
		String line;
		String[] token;
		int i, pos;
		double t, logc;
				
		// initialize next time series
		next = new PmmTimeSeries();
		
		while( true ) {
			
			line = reader.readLine();

			if( line == null ) {
				next = null;
				return;
			}
			
			// split up token
			token = line.split( "\t" );
						
			if( token.length < 2 )
				continue;
			
			if( token[ 0 ].isEmpty() )
				continue;
			
			for( i = 0; i < token.length; i++ )
				token[ i ] = token[ i ].replaceAll( "[^a-zA-Z0-9° \\.\\(\\)_/\\+\\-\\*,:]", "" );
			token[ 0 ] = token[ 0 ].toLowerCase();
			
			// fetch record id
			if( token[ 0 ].equals( "recordid" ) ) {
				next.recordId = token[ 1 ];
				continue;
			}
			
			// fetch organism
			if( token[ 0 ].equals( "organism" ) ) {
				next.organism = token[ 1 ];
				continue;
			}
			
			// fetch environment
			if( token[ 0 ].equals( "environment" ) ) {
				next.environment = token[ 1 ];
				continue;
			}
			
			// fetch temperature
			if( token[ 0 ].equals( "temperature" ) ) {
				
				pos = token[ 1 ].indexOf( " " );
				if( !token[ 1 ].endsWith( " °C" ) )
					throw new Exception( "Temperature unit must be [°C]" );
				next.temperature = parse( token[ 1 ].substring( 0, pos ) );
				continue;
			}
			
			// fetch pH
			if( token[ 0 ].equals( "ph" ) ) {
				next.ph = parse( token[ 1 ] );
				continue;
			}
			
			// fetch water activity
			if( token[ 0 ].equals( "water activity" ) ) {
				next.waterActivity = parse( token[ 1 ] );
				if( next.waterActivity != Double.NaN )
					if( next.waterActivity < 0 || next.waterActivity > 1 )
						throw new Exception( "Water activity must be in [0, 1]." );
				continue;
			}
			
			// fetch conditions
			if( token[ 0 ].equals( "conditions" ) ) {
				next.conditions = token[ 1 ];
				continue;
			}
			
			// fetch maximum rate
			if( token[ 0 ].equals( "maximum rate" ) ) {

				next.maximumRate = parse( token[ 1 ] );
				continue;
			}
			
			if( token[ 0 ].startsWith( "doubling time" ) ) {
				
				next.doublingTime = parse( token[ 1 ] );
				continue;
			}
			
			if( token[ 0 ].startsWith( "time" ) && token[ 1 ].equals( "logc" ) ) {
				
				if( !token[ 0 ].endsWith( " (h)" ) )
					throw new Exception( "Time unit must be [h]." );
				
				while( true ) {
					
					line = reader.readLine();
					
					if( line == null )
						return;
					
					if( line.replaceAll( "\\t\"", "" ).isEmpty() )
						break;
					
					token = line.split( "\t" );
					
					for( i = 0; i < token.length; i++ )
						token[ i ] = token[ i ].replaceAll( "[^a-zA-Z0-9° \\.\\(\\)/,]", "" );
					
					if( token.length < 2 )
						break;

					t = parse( token[ 0 ] );
					logc = parse( token[ 1 ] );
					
					if( t == Double.NaN || logc == Double.NaN )
						continue;
					
					next.ts.add( new double[] { t, logc } );

					
				}
				break;
			}
		}
	}
	
	private static double parse( String num ) {
		
		double n;
		
		n = Double.NaN;
		
		num = num.toLowerCase();
		num = num.trim();
		if( num.equals( "no growth" ) )
			return 0;
		
		
		try {
			
			num = num.replaceAll( "[a-zA-Z\\(\\)\\s]", "" );
			num = num.replaceAll( ",", "." );
			n = Double.valueOf( num );
			
		}
		catch( Exception e ) {}
		
		return n;
	}

}
